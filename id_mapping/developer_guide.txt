*********************************************
* Ensembl stable ID mapping developer guide *
*********************************************

Author: Patrick Meidl <meidl@ebi.ac.uk>

Please post questions to the Ensembl developers mailinglist
<ensembl-dev@ebi.ac.uk>


This document describes the technical details of the Ensembl stable ID mapping
implementation. It's intended for people who need to modify or extend the
existing code. If you merely want the run the stable ID mapping, please refer
to user_guide.txt.


Table of content
================

Files
Design overview
Configuration
Logging
How to extend the application
Wishlist
Known issues


-------------------------------------------------------------------------------
Design overview
-------------------------------------------------------------------------------

- explain algorithm

- explain how code is split up into scripts and modules: wrappers, components,
  lsf, ...

- comparison with Java version:
  - checkpointing is better (faster)


-------------------------------------------------------------------------------
Configuration
-------------------------------------------------------------------------------

- explain ConfParser:
  - conf file, overwritten by commandline arguments
  - validity, requirement checks done
  - implicit (general) parameters
  - how to access parameters in your script


-------------------------------------------------------------------------------
Logging
-------------------------------------------------------------------------------

- explain how Logger works:
  - log to file, fallback to STDERR
  - caveats when using lsf

- log level:
  - guide on which levels to use
  - how to set log level


-------------------------------------------------------------------------------
Wishlist
-------------------------------------------------------------------------------


-------------------------------------------------------------------------------
Known issues
-------------------------------------------------------------------------------

1. Cache and serialisation:

The cache allows lookup of object by different properties (e.g. you can get
genes by gene ID or by transcript ID). When the cache is initially created, you
will get identical gene objects back from these different calls. But after
serialisation and deserialisation of the cache, the different cache hashes will
point to different object (the two genes will have the same properties, but
reference two different memory locations). This can become an issue when you
modify an object retrieved from one hash, then get the (supposedly) same object
from another hash - you will find that your modifications aren't there.

