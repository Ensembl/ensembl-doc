This is a file which should describe how to use the pipeline blast modules
and what the customzable pieces of the blast code need to work

Our blast analysis is based around a runnable/runnabledb pair found in
Bio::EnsEMBL::Analysis::Runnable/RunnableDB

I will first describe the runnable, then the runnaledb and the modules 
which are plugged into the system, then I will talk about ways you might
want to use the system. 

Bio::EnsEMBL::Analysis::Runnable::Blast
---------------------------------------

This is a very bare bones module which doesn't do an awful lot for itself
It knows how to construct the blast commandline and run the command but 
any parsing and filtering of results is left to other modules.

The constructor requires 2 arguments on top of what the base class 
constructor expects (ie an query sequence and an analysis object see 
Runnable.spec),  a database name which should be a name of a database 
which lives in whatever directory is pointed to in your $BLASTDB env 
variable or the full path to a directory (note it can also be one 
directory down from $BLASTDB ie EnsEMBL/swall is allow but 
blastdb/EnsEMBL/swall wouldn't work unless it was the full path) and 
a parser object which will be desribed in full further down in this 
document

The constructor also takes. A filter object which will filter the
results returned by the parser. A type which specifies whether the 
analysis should construct a wublast or ncbi blast style command line by 
default it constructs a wublast style command and an unknown error string
which is what string blast returns if it fails with an error on stderr the
code doesn't regconise by default this is FAILED to allow the pipeline
run analyses to retry the jobs

The blast runnable still has the standard runnable methods of run and
output. How run method is actually taken from the base class. It calls
to run_analysis to construct the commandline to each of the databases 
being run against then to parse_results to parse all the files produces, 
parse_results doesnt do any parsing itself though it but passes an 
arrayref of filenames to the parser object which then returns a set of 
results if a filter object exists then results are then passed to the 
filter before being put into the output array. This is where the standard
methods any parser object or filter object is expected to have comes into
play. All parser objects are expected to have a parse_file method which
takes an arrayref of filenames and returns an arrayref of appropriate
objects to represent the blast results and all filter objects need a 
method called filter_results which takes an arrayref of features an 
returns an array ref of the filtered set. As previously mentioned the
parser and filter objects will be described in more detail further down


Bio::EnsEMBL::Analysis::Config::Blast
-------------------------------------

As the complex code in the runnabledb mostly depends on how it reads its
config file I thought I would explain that first before talking about the
runnable

The Config file has two main variables. One, BLAST_AB_INITO_LOGICNAME
is only used by BlastGenscanPep and BlastGenscanDNA an it specifies which
type of ab initio analysis to fetch out of the database. The other 
BLAST_CONFIG is an array of hashes which describe the various setup 
details for the blast runnable. 


{           
 logic_name => 'Swall',
 blast_parser => 'Bio::EnsEMBL::Analysis::Tools::FilterBPlite',
 parser_params => {
                   -regex => '^\w+\s+(\w+)',
                   -query_type => 'pep',
                   -database_type => 'pep',
                   -threshold_type => 'PVALUE',
                   -threshold => 0.01,
                  },
 blast_filter => 'Bio::EnsEMBL::Analysis::Tools::FeatureFilter',
 filter_params => {
                   -min_score => 200,
                   -prune => 1,
                  },
 blast_params => {
                  -unknown_error_string => 'FAILED',
                  -type => 'wu',
                 },
}

logic_name is the key which unique identifies each set of config, this 
logic_name should match the logic_name for the same analysis in the 
database

blast_parser which blast parser object to require (more about these below)

parser_params any constructor parameters for the parser

blast_filter which filter object to require

filter_params any constructor arguments the filter object needs

blast_params any constructor arguments for 
Bio::EnsEMBL::Analysis::Runnable::Blast

A parser object is compulsory for blast but a filter object is not. Only
the blast constructor can take arguments from the a parameters column
of the analysis table but values here will be overridden by the parameters
string if they are present in it

Bio::EnsEMBL::Analysis::RunnableDB::Blast
-----------------------------------------

the blast runnabledb expects the standard runnabledb constructor args
input_id, database handle and analysis object

The fetch_input method not only fetches the sequence before instantiating
the runnable but also reads the config and sets up the parser and filter 
objects if appropriate

as already mentioned if you put entries in the parameters column of
the analysis table which are parsed into hashs by the parameters hash they
will override any blast constructor args in the config


Parser objects
--------------

All parser objects must provide a method called parse_files which takes
an arrayref of filenames and returns an arrayref of feature objects. Other
than that their form is free.

There are two existing parser objects in the system

Bio::EnsEMBL::Analysis::Tools::BPliteWrapper

this is just a straigt wrapper for BPlite it returns everything BPlite
produces with no filtering

Bio::EnsEMBL::Analysis::Tools::FilterBPlite

this replicates the prefiltering that the old pipeline blast runnable
used to do so it throws out features which don't pass a certain cut off
and filters using the feature filter described below before parsing the
hsps into alignfeatures


Filter objects
--------------

All filter objects must provide a method called filter_results which takes
and arrayref of results and returns an arrayref of the filtered set

Only on filter object currently exists

Bio::EnsEMBL::Analysis::Tools::FeatureFilter

this effectively is an exact replicar of the old pipeline feature filter
and will filter in the same way. It has complete documentation which 
should explain the basis for its filtering


Using the blast modules
-----------------------

Most people will just use the blast modules in the Runnable/RunnableDB 
pair which means before running you should just need to have an analysis
object and fill out the config files. The BlastGenscan runnabledbs also
use the same config and work in the same fashion.

If you want to use just the Blast Runnable in a script or pipeline
analysis you will need to make sure you have an appropriate parser
and filter object. You can use the config to set them up if you want
look in the RunnableDB for an example of the a parsing code
but if the setings are stationary you can also just hard code them




