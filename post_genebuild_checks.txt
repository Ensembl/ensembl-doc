Post genebuild checks (Last modified 09-January-2003)
---------------------

You can get most of the checks done by running 

ensembl-pipeline/scripts/post_GeneBuild/post_GeneBuild_checks.pl

Example: post_GeneBuild_checks.pl -dbname homo_sapiens_core_9_30 -dbhost ecs2d -dnadbname homo_sapiens_core_9_30 -dnadbhost ecs2d -genetype ensembl > & check &

It checks

1.- all exons in a gene are in the same strand
2.- it checks that phases are consistent between exons
3.- also checks for folded transcripts
4.- it flags also single exon genes and from these, the ones which are longer than 50000 bases

This document describes the steps that we currently take to check data
from the gene build. Where possible sample sql or perl that
should test for these things are included.

These are the steps that currently need to be taken before a genebuild
database is handed over to the post-compute team:

######################
# CHECK THE ASSEMBLY #
######################

check that your assembly type follows the convention:

Rat:            RGSCx
Fly:            DROMx
Zebrafish:      ZFISHx
Fugu:           FUGUx
Mosquito:       MOZx
C. elegans:     CELx
C. briggsae:    CBRx
Mouse:          MGSCx
Human:          NCBIx

where x is the assembly number


###################
# checks on exons #
###################

1. check for duplicate exons

   select e1.exon_id as exon1, e2.exon_id as exon2 from exon e1, exon e2 
where e1.contig_start = e2.contig_start and e1.contig_end=e2.contig_end 
and e1.contig_strand=e2.contig_strand and e1.phase=e2.phase and 
e1.end_phase=e2.end_phase and e1.exon_id != e2.exon_id and e1.contig_id 
= e2.contig_id;
  
     note that there may be exons that are identical but as a part of a sticky-exon: 
     Two exons with different ids may
     have the same entries but be the sticky_rank 2, say, of two different sticky exons.

2. check for sane exon coords
     select count(*) from exon where contig_start < 1;
     select count(*) from exon where contig_start > contig_end;
     select count(exon_id) from exon, contig where exon.contig_id =contig.contig_id and exon.contig_end > contig.length;	  

     note that until we have a better way of storing genewise frameshifts we will have very small exons ( < 10bases ) so not much point in testing seq_start=seq_end. 


2. check that all exons belong to some transcript:
    
    select count(distinct e.exon_id) from exon e left join exon_transcript et on e.exon_id =et.exon_id where et.exon_id is null;


3. check how many contigs have no exons on them. In Human is about half of the contigs:

    select count(distinct a.contig_id) from assembly a left join exon e on e.contig_id = a.contig_id where e.contig_id is null;


3. check for too short exons ( < 10 bases long ): Have a look to them and see whether they look real or not.
     select (contig_end-contig_start+1) as s, sticky_rank, exon_id  from exon where (contig_end-contig_start+1)<10;
     
     check whether they are sticky exons, this is usually the case.
     check whether they have any evidence:

     select (contig_end-contig_start+1) as s, sticky_rank, exon.exon_id, sf.feature_id from exon, supporting_feature sf where (contig_end-contig_start+1)<10 and sf.exon_id = exon.exon_id;


4. check very short introns  ( < 50 bases long ): Have a look to them and see whether they look real or not.

5. exons with no supporting feature data - there will be some but it should not be an enormous number!
     select count(exon.exon_id) from exon left join supporting_feature on exon.exon_id=supporting_feature.exon_id where supporting_feature.exon_id is NULL;

6. If you want to print the chromosome where those exons fall:

     select distinct(e.exon_id), c.name, a.chr_start, a.chr_end from chromosome c, assembly a, exon e left join supporting_feature on e.exon_id=supporting_feature.exon_id where supporting_feature.exon_id is NULL and e.contig_id = a.contig_id and c.chromosome_id = a.chromosome_id;



###################
# checks on genes #
###################


1. all genes have transcripts
    select count(gene.gene_id) from gene left join transcript on gene.gene_id=transcript.gene_id where transcript.gene_id is NULL;

2. all transcripts have exons
    select count(transcript.transcript_id) from transcript left join exon_transcript on transcript.transcript_id=exon_transcript.transcript_id where exon_transcript.transcript_id is NULL;

3. all transcripts belong to a gene
   select count(distinct t.transcript_id) from transcript t left join gene g on g.gene_id =t.gene_id where g.gene_id is null;

4. check that there are no too-long single exon genes (>50kb)
     start with 
  select exon_id,  (contig_end - contig_start +1 ) as length  from exon having length > 50000; 
     and pick out those that are single exon genes - should not be any.

5. you can also have a look at how many single-exon genes there are
     select count(*) as c,transcript_id from exon_transcript group by transcript_id having c=1;



##########################
# checks on translations #
##########################

1. dump out peptide file - there should be no transcripts that do not translate - if there are, they need to be got rid of
   (check that no translation has stop codons in it)

3. check for short translation.  Have a look to those very short ones, let's say < 10 aa, and see whether they look real.


4. check that all transcripts have a translation      
     select count(gene.gene_id) from gene left join transcript on gene.gene_id=transcript.gene_id where transcript.gene_id is NULL;

    select count(t.transcript_id) from transcript t left join translation tr on t.transcript_id = tr.translation_id where t.translation_id is NULL;
   

4. check that if the start and end of translation is on the same exon, that start < end:

   select count(translation_id) from translation where start_exon_id = end_exon_id and seq_start > seq_end;




#####################
# checks on contigs #
#####################

* Prune non-golden clones, dna 
  (these are the bits from the contigs which do not form part of the tiling path)

  Note: this is not necessary in a denormalised golden path, as the denormalisation would have got rid of them


###################################
# checks on features and analyses #
###################################

1. Prune dangling (non-golden) features
   (these are the features anchored on bits of contigs which do not form part of the tiling path)

2. remove blast features which score < 150
   ( maybe also prune similarity features with bit score < 80?)

3. check analysis - there must be no features with an invalid analysis id!

     select analysis_id, logic_name from analysis;
     select analysis_id, count(*) from dna_align_feature group by analysis_id;
     select analysis_id, count(*) from protein_align_feature group by analysis_id ;
     select analysis_id, count(*) from protein_feature group by analysis_id ;
     select analysis_id, count(*) from simple_feature group by analysis_id;
     select analysis_id, count(*) from gene group by analysis_id;
  
4. check that all features map to analysis. All analyses have a 'db'. Logic names should be stable. 

Example for human:
mysql> select logic_name, analysis_id, db, module, gff_feature, gff_source from analysis order by analysis_id ;
+---------------+-------------+--------------------+-----------------------+---------------+--------------+
| logic_name    | analysis_id | db                 | module                | gff_feature   | gff_source   |
+---------------+-------------+--------------------+-----------------------+---------------+--------------+
| human_cdna    |           1 | RefSeq-EMBL        | BlatToGene            | cdna          | blat         |
| RepeatMask    |           2 | repbase            | RepeatMasker          | repeat        | RepeatMasker |
| Genscan       |           3 | HumanIso.smat      | Genscan               | prediction    | genscan      |
| tRNAscan      |           4 | tRNA               | tRNAscan_SE           | tRNA          | tRNAscan-SE  |
| Swall         |           5 | swall              | BlastGenscanPep       | similarity    | wublastp     |
| Dust          |           6 |                    | Slice_Dust            | dust          | dust         |
| Vertrna       |           7 | embl_vertrna       | BlastGenscanDNA       | similarity    | wutblastn    |
| CpG           |           8 | cpg                | CPG                   | cpg_island    | cpg          |
| Unigene       |           9 | unigene.seq        | BlastGenscanDNA       | similarity    | wutblastn    |
| Eponine       |          17 | NULL               | Slice_EponineTSS      | TSS           | Eponine      |
| TRF           |          18 |                    | TRF                   | tandem_repeat | trf          |
| Mapprimer130  |          50 | Markers.dat        | Slice_EPCR            | sts           | e-PCR        |
| human_protein |          58 | RefSeq-SPproteomes | TargettedGenewise     | protein       | genewise     |
| other_protein |          59 | swall              | FPC_BlastMiniGenewise | protein       | genewise     |
| ensembl       |          61 | ensembl            | GeneCombiner          | gene          | ensembl      |
+---------------+-------------+--------------------+-----------------------+---------------+--------------+

make sure things are properly defined and they have useful names

5. check for sane feature coordinates

     select count(*) from dna_align_feature where hit_start > hit_end;
     select count(*) from dna_align_feature where hit_start < 1;
     
     select count(*) from protein_align_feature where hit_start > hit_end;     
     select count(*) from protein_align_feature where hit_start < 1;     
     
     select count(*) from dna_align_feature where contig_start > contig_end;
     select count(*) from dna_align_feature where contig_start < 1;
     select count(dna_align_feature_id) from dna_align_feature f, contig c where f.contig_id = c.contig_id and f.contig_end > c.length;

     select count(*) from protein_align_feature where contig_start > contig_end;
     select count(*) from protein_align_feature where contig_start < 1;
     select count(protein_align_feature_id) from protein_align_feature f, contig c where f.contig_id = c.contig_id and f.contig_end > c.length;

6. prune duplicate features 

  Note: there are two feature tables and they are linked to the exon table
        ( it is very slow in sql. It could be done per analysis, but it is nevertheless slow. Maybe better to do it in the tab-delimited files:     

     select distinct contig_id, contig_start, contig_end, contig_strand, hit_start, hit_end, hit_name, analysis_id, score, evalue, perc_ident, cigar_line from dna_align_feature into outfile '/path/to/outfile';

     select distinct contig_id, contig_start, contig_end, contig_strand, hit_start, hit_end, hit_name, analysis_id, score, evalue, perc_ident, cigar_line from protein_align_feature into outfile '/path/to/outfile';

  and then add a \N as first column and upload the outfile into a empty new feature table. 

  If the actual order in the table is irrelevant, it is maybe easier to do 
  shell> sort -u -k 2 feature_filename
  in the files and then upload the results. This is also faster if split the features (maybe by analysis, or by its origin: pipeline, interim genebuild, cdna_features) and you do it independently for each set

###########################
# Finally, Make a backup! #
###########################














