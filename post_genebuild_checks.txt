Post genebuild checks (Last modified 18-November-2002)
---------------------

You can get most of the checks done by running 

ensembl-pipeline/scripts/post_GeneBuild/post_GeneBuild_checks.pl

Example: post_GeneBuild_checks.pl -dbname homo_sapiens_core_9_30 -dbhost ecs2d -dnadbname homo_sapiens_core_9_30 -dnadbhost ecs2d -genetype ensembl > & check &

It checks

1.- all exons in a gene are in the same strand
2.- it checks that phases are consistent between exons
3.- also checks for folded transcripts
4.- it flags also single exon genes and from these, the ones which are longer than 50000 bases

This document describes the steps that we currently take to check data
from the gene build. Where possible sample sql or perl that
should test for these things are included.

These are the steps that currently need to be taken before a genebuild
database is handed over to the post-compute team:

###################
# checks on exons #
###################

1. check for duplicate exons

     select e1.exon_id as exon1, e2.exon_id as exon2 from exon e1, exon e2 where e1.seq_start = e2.seq_start and e1.seq_end=e2.seq_end and e1.strand=e2.strand and e1.phase=e2.phase and e1.end_phase=e2.end_phase and e1.exon_id != e2.exon_id;

     note that there may be exons that are identical but as a part of a sticky-exon: Two exons with different ids may
     have the same entries but be the sticky_rank 2, say, of two different sticky exons.

2. check for sane exon coords
     select * from exon where seq_start < 1;
     select * from exon where seq_start > seq_end;
     select exon_id from exon, contig where exon.contig_id =contig.internal_id and exon.seq_end > contig.length;

     note that until we have a better way of storing genewise frameshifts we will have very small exons ( < 10bases ) so not much point in testing seq_start=seq_end. 


2. check that all exons belong to some transcript:
    
    select count(distinct e.exon_id) from exon e left join exon_transcript et on e.exon_id =et.exon_id where et.exon_id is null;

3. check for too short exons ( < 10 bases long ): Have a look to them and see whether they look real or not.
     select (seq_end-seq_start+1) as s, sticky_rank, exon_id  from exon where (seq_end-seq_start+1)<10;
     
     check whether they are sticky exons, this is usually the case.


4. check very short introns  ( < 50 bases long ): Have a look to them and see whether they look real or not.

5. exons with no supporting feature data - there will be some but it should not be an enormous number!
     select count(exon.exon_id) from exon left join supporting_feature on exon.exon_id=supporting_feature.exon_id where supporting_feature.exon_id is NULL;



###################
# checks on genes #
###################


Note: The checks done in the object layer are in script form in 
ensembl-pipeline/scripts/post_GeneBuild/post_GeneBuild_checks_denormalised.pl
although this script is specialised for mouse, where do far we are using a denormalised assembly.


1. all genes have transcripts
    select count(gene.gene_id) from gene left join transcript on gene.gene_id=transcript.gene_id where transcript.gene_id is NULL;

2. all transcripts have exons
    select count(transcript.transcript_id) from transcript left join exon_transcript on transcript.transcript_id=exon_transcript.transcript_id where exon_transcript.transcript_id is NULL;


3. all exons for a gene are on the same strand (VC not RC!)
   done through object layer, one VC at a time:

GENE: foreach my $gene($vc->get_Genes_by_Type($genetype)){
  # check all exons are on the same strand
  my $strand;
  foreach my $exon($gene->get_all_Exons){
    if(!defined $exon->strand || ($exon->strand != 1 && $exon->strand != -1)){
      print STDERR "Exon " . $exon->dbID . " has no strand!!\n";
      next GENE;
    }
    if(!defined $strand){ $strand = $exon->strand; }
    if($exon->strand != $strand){
      print STDERR "strand problem with gene " . $gene->dbID . "\n";
      next GENE;
    }
  }

 
4. check there are no folded transcripts
   done through object layer, on VCs (also part of genebuild now so should be none.)

GENE: foreach my $gene($vc->get_Genes_by_Type($genetype)){
  foreach my $transcript($gene->each_Transcript){
    my @exons = $transcript->get_all_Exons;
    my $i;
     for ($i = 1; $i < $#exons; $i++) {
       if ($exons[0]->strand == 1) {
	 if ($exons[$i]->start < $exons[$i-1]->end) {
	   print STDERR "ERROR:  Transcript folds back on itself. Transcript : " . $transcript->dbID . "\n";
	   next GENE;
	 } 
       } elsif ($exons[0]->strand == -1) {
	 if ($exons[$i]->end > $exons[$i-1]->start) {
	   print STDERR "ERROR:  Transcript folds back on itself. Transcript : " . $transcript->dbID . "\n";
	   next GENE;
	 } 
       } else {
	 print STDERR "EEEK:In transcript  " . $transcript->dbID . " No strand for exon - can't check for folded transcript\n";
       }
     }
  }
}


5. check that there are no too-long single exon genes (>50kb)
     start with 
     select exon_id from exon where seq_end -seq_start > 50000; 
     and pick out those that are single exon genes - should not be any.

6. you can also have a look at how many single-exon genes there are
     select count(*) as c,transcript_id from exon_transcript group by transcript_id having c=1;



##########################
# checks on translations #
##########################

1. dump out peptide file - there should be no transcripts that do not translate - if there are, they need to be got rid of
   (check that no translation has stop codons in it)

3. check for short translation.  Have a look to those very short ones, let's say < 10 aa, and see whether they look real.


#####################
# checks on contigs #
#####################

* Prune non-golden clones, dna 
  (these are the bits from the contigs which do not form part of the tiling path)

  Note: this is not necessary in a denormalised golden path, as the denormalisation would have got rid of them


###################################
# checks on features and analyses #
###################################

1. Prune dangling (non-golden) features
   (these are the features anchored on bits of contigs which do not form part of the tiling path)

2. remove blast features which score < 150
   ( maybe also prune similarity features with bit score < 80?)

3. check analysisprocesses - there must be no features with an invalid analysis id!

4. check that all features map to analysisprocess. All analyses have a 'db'. Logic names should be stable. 

5. check for sane feature coordinates

     select * from feature where hstart > hend;
     select * from feature where hstart < 1;

     select * from supporting_feature where hstart > hend;
     select * from supporting_feature where hstart < 1;  

     select * from feature where seq_start > seq_end;
     select * from feature where seq_start < 1;
     select feature.id from feature, contig where feature.contig = contig.internal_id and feature.seq_end > contig.length;

     select * from supporting_feature where seq_start > seq_end;
     select * from supporting_feature where seq_start < 1;
     select supporting_feature.supporting_feature_id from supporting_feature, contig where supporting_feature.contig_id = contig.internal_id and supporting_feature.seq_end > contig.length;


6. prune duplicate features (except genscan - because they might have feature-sets hanging from them.) 
   
   To check for duplicate features:

     select f1.id as feature1, f2.id as feature2 from feature f1, feature f2 where f1.contig = f2.contig and f1.seq_start = f2.seq_start and f1.seq_end = f2.seq_end and f1.strand = f2.strand and f1.analysis = f2.analysis and f1.name = f2.name and f1.hstart = f2.hstart and f1.hend = f2.hend and f1.score = f2.score
          
     ( it is very slow in sql. It could be done per analysis, but it is nevertheless slow. Maybe better to do it in the tab-delimited files)

   another possibility on how to remove duplicates:
     
     select distinct contig, seq_start, seq_end, score, strand, analysis, name, hstart, hend, hid, evalue, perc_id, phase, end_phase from feature into outfile '/path/to/outfile';
 
  and then add a \N as first column and upload the outfile into a empty new feature table. 

  If the actual order in the table is irrelevant, it is maybe easier to do 
  shell> sort -u -k 2 feature_filename
  in the files and then upload the results. This is also faster if split the features (maybe by analysis, or by
  its origin: pipeline, interim genebuild, cdna_features) and you do it independently for each set


8. If you're including supporting features in the final database it would be good to
check also for duplicates in this table
     


#######################
# test function calls #
#######################

(these may not all be relevant, depending on organism):

my @genes    = $vc->get_all_Genes_exononly();
my @genes    = $vc->get_all_Genes('evidence');

my @tmpgenes = $vc->get_Genes_by_Type(***REMOVED***,'evidence');
my @preds    = $vc->get_all_PredictionFeatures;


@features  = $vc->get_all_SimilarityFeatures_above_score('cpg',25);
@features  = $vc->get_all_SimilarityFeatures_above_score('trna',80);
@features  = $vc->get_all_SimilarityFeatures_above_score('unigene.seq',80);
@features  = $vc->get_all_SimilarityFeatures_above_score('embl_vertrna',80);
@features  = $vc->get_all_SimilarityFeatures_above_score('dbEST',1,0);
@features  = $vc->get_all_SimilarityFeatures_above_score('swall',1);
@features  = $vc->get_all_SimilarityFeatures_above_score('human_mrna',1);




###########################
# Finally, Make a backup! #
###########################
